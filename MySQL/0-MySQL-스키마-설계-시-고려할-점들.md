정리중.... ㅠㅠ 빠르게 정리완료예정!!

다른 DB에도 적용되는 공통적인 내용도 있지만, 이 글은 MySQL의 InnoDB에 국한된 내용이 대부분이다. 일을 하다보면 MySQL 외의 다른 DB도 사용할 일이 분명히 있을 것이라고 생각한다. 다른 DB도 차차 공부한 내용들을 정리해나갈 예정이다.

화이자!!!



# 참고자료

[MySQL 성능 최적화](http://www.yes24.com/Product/Goods/112622445)

<br>

# 데이터 타입 선택시 고려하는 것들

**작을 수록 좋다.**

- 작을 수록 좋지만, 너무 작게 데이터 타입을 정해서 스키마의 여기 저기에서 데이터 유형의 사이즈를 키워야 하는 상황이 온다면 꽤 번거롭고, 데이터가 이미 많이 쌓여 있는 경우 시간이 많이 걸리는 작업이 될 수 있다.
- 따라서 저장해야 하는 값의 범위를 과소평가해서는 안된다.
- 초과하지 않을 것 같은 범위에서 가장 작은 데이터 타입을 고르자
- 항상 시간이 많이 걸리는 작업은 아니다.
- 데이터가 실제로 많이 저장되지 않는 테이블이거나 설계 초기의 테이블일 경우 나중에 쉽게 변경 가능하다. 유연하게 상황판단을 해서 대용량 테이블으로 사용될 것 같다는 생각이 든다면, 신중하게 판단해야 한다.

<br>

**단순할수록 좋다.**
데이터 타입이 더 단순한 타입일수록 작업 처리시 더 적은 CPU 주기가 필요하다는 장점이 있다.

e.g.

- 문자 데이터들에 대한 데이터 정렬
  - 문자 비교를 복잡하게 만들기 때문에 문자열 대신 정수 또는 기본 타입으로 저장 가능한지를 고려해보면 좋다.
  - 예를 들면 아래와 같은 케이스들이 있다.
  - 날짜,시간 타입에 문자열대신 날짜,시간을 저장
  - IP 주소를 저장하는 데에 문자열 대신 정수를 저장

<br>

**가급적 `NULL` 을 피할 수록 좋다.**
`NULL` 보다는 `NOT NULL` 이 가능하다면 `NOT NULL` 을 지정

- 애플리케이션 측에서 대부분 값이 지정되지 않은 값을 `NULL` 로 지정하여 저장하는 경우가 많다. `NULL` 로 저장할 의도가 분명한 것이 아니라면 가급적 열을 `NOT NULL` 로 지정하자.

  

조회를 위한 인덱스 사용, 값 비교 사용시 `NULL` 의 불리함

- MySQL은 인덱스, 인덱스 통계/값 비교를 복잡하게 만든다. 따라서 NULL 가능한 열을 참조하는 쿼리는 최적화하기 쉽지 않다.

<br>

**스토리지 공간, 스토리지 엔진 측면에서의 비효율**
NULL 가능한 열은 더 많은 스토리지 공간을 사용하고, MYSQL 내부에서 특별한 처리가 필요하다.

<br>

**관대함은 현명하지 못할 수 있다.**<br>

'hello' 값을 저장할 때 VARCHAR(5) 및 VARCHAR(200) 열에 동일한 양의 공간이 필요하다. 더 짧은 열을 사용하는 것은 이익이 되는 것일까?<br>

결론만 따지면, 이익이 된다. 더 큰 열을 사용하면 훨씬 더 많은 메모리를 사용할 수 있다. MySQL 은 종종 내부적으로 값을 유지하기 위해 고정 크기의 메모리 청크를 할당하기 때문이다.<br>

이것은 메모리 내의 임시 테이블을 사용하는 정렬 또는 작업에 좋지 않다. 디스크에 있는 임시 테이블을 사용하는 파일 정렬에도 동일한 일이 발생한다. <br>

가장 좋은 전략은 실제로 필요한 만큼만 공간을 할당하는 것이다.<br>

<br>

# 대표적인 데이터 타입들

- 정수
- 실수
- 문자열유형
- VARCHAR, CHAR
  - VARCHAR, CHAR 의 저장방식
  - VARCHAR의 길이정보 기록 바이트
  - VARCHAR 의 단점과 VARCHAR를 사용하면 좋은 경우
  - CHAR 의 장단점과 CHAR를 사용하면 좋은 경우
  - CHAR의 후행공백 예제
  - 관대함은 현명하지 못할 수 있다.
- BLOB, TEXT
- 문자열, ENUM
- DATE, TIME
- 비트 팩 데이터 타입
- JSON 데이터

<br>

## 정수

정수 타입에는 `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT` , `BIGINT` 등이 있다. 각 타입은 8, 16, 24, 32, 64 비트의 저장 공간이 필요하다. `-2^(n-1) ~ 2(N-1)` 까지의 값을 저장가능하다. (N은 저장공간의 비트 수)<br>

**SIGNED, UNSIGNED**<br>

정수유형의 데이터 타입에는 `UNSIGNED`를 선택해서 지정하는 것이 가능하다.<br>

`SIGNED`, `UNSIGNED` 는 같은 범위의 스토리지 공간을 사용하고, 동일한 성능을 가진다. 데이터 범위에 적합한 유형을 사용하면 된다.

e.g. `TINY INT UNSIGNED` <br>

- `0~255` 사이의 값을 저장할 수 있다. 

e.g. `TINY INT SIGNED`<br>

- `-128 ~ 127` 까지의 값을 저장가능하다

<br>

**계산시에 MYSQL 이 암묵적으로 선택하는 정수자료형**<br>

데이터 저장의 경우 사용자의 선택에 따라 MySQL의 메모리, 디스크에 데이터를 저장하는 방법이 결정된다.<br>

데이터 계산을 할 때는 MySQL은 때에 따라 다르게 정수타입을 선택한다.<br>

- 데이터 계산시 일반적으로는 BIGINT를 사용한다.<br>

- 일부 집계함수의 경우 계산을 수행하기 위해 `DECIMAL`, `DOUBLE` 을 사용한다.

<br>

## 실수

실수는 소수 부분이 존재하는 숫자다. 그러나, 소수만을 위한 데이터 타입은 아니다. 

`FLOAT`,`DOUBLE` <br>

- 부동소수점 연산으로 근사계산을 수행
- 부동소수점 겨로가가 어떻게 계산되는지 `정확하게` 알아야 하는 경우 플랫폼의 부동 소수점 구현을 확인해야 한다.
- e.g. 
  - 자바의 경우 정확한 계산은 Float, Double 타입의 사용을 가급적 피하도록 권장하고 있다. (Effective Java, Java 프로그래머를 위한 97가지 조언)
- 부동소수점 지정시 

<br>

`DECIMAL`, `BIGINT`

- 재무 데이터를 저장할 때 처럼 정확한 결과가 필요한 경우 `DECIMAL` 을 사용해야 한다.
- 일부 대용량 사례에서는 `BIGINT` 를 대신 사용하고 최소 통화량의 배수로 데이터를 저장하는 방식을 채택한다. 이렇게 하면, 데이터의 사이즈를 줄일 수 있기에 바람직한 방법이다.
- e.g. 재무데이터를 1/10000 까지 저장해야 하는 경우
  - 모든 달러 금액에 100만 달러를 곱하면 BIGINT에 저장할 수 있다.
  - 이렇게 하면 부동 소수점 저장으로 인한 부정확성을 방지할 수 있고 `DECIMAL` 연산 비용이 들지 않는다.



## 문자열 유형

## VARCHAR 와 CHAR

> 스토리지 엔진에 따라 VARCHAR, CHAR 자료형의 구현이 달라진다. 이 문서에서는 InnoDB엔진에 한정해서 내용을 정리.

<br>

**VARCHAR, CHAR 의 저장방식**<br>

VARCHAR, CHAR 의 저장방식만을 정리해보면 아래와 같다.

- VARCHAR : 가변적인 문자열
  - 필요한 문자열크기보다 작은 데이터를 저장하면 나머지 공간은 제외하고 필요한 공간 만큼만 저장
  - e.g. VARCHAR(10) 타입 컬럼 `player`
    - `player` 컬럼에 `kane` 을 저장할 경우 실제로 스토리지 엔진이 디스크에 데이터를 저장할 때 5바이트의 공간을 지정해 저장하게 된다. 문자열 길이 4바이트 + 1바이트(길이정보)다.

- CHAR : 고정 문자열
  - 컬럼의 사이즈보다 더 작은 크기의 데이터가 들어오더라도, 고정된 크기의 컬럼 크기는 변하지 않는다.
  - CHAR 타입의 데이터를 저장할 때 MySQL은 항상 후행 공백을 제거한다.
  - 필요에 의해 값의 비교시에는 공백으로 채워진다.
  - 짧은 문자열을 저장하려는 경우 또는 모든 값의 길이가 거의 동일한 경우에 유용하다.
  - e.g. CHAR(10) 타입 컬럼 `player`
    - `player` 컬럼에 `kane` 을 저장할 경우 실제로 스토리지 엔진이 디스크에 데이터를 저장할 때 10바이트의 공간을 고정적으로 지정해 저장하게 된다. 
  - e.g. `MD5` 인코딩된 사용자 암호
    - MD5 방식으로 인코딩된 데이터는 항상 길이가 동일하다. 암호를 MD5로 인코딩했다고 해보자. 이런 경우 MD5로 인코딩된 문자열은 `CHAR` 타입을 이용하기에 적절하다.
    - 

<br>

**VARCHAR의 길이정보 기록 바이트**<br>

- VARCHAR 는 1바이트 또는 2바이트를 추가로 사용해 저장하려는 데이터의 길이 역시 추가로 기록한다.
- e.g. VARCHAR(10) 타입 컬럼 `player`
  - player 컬럼에 문자열 `kane` 을 저장할 경우, 그리고 `player` 컬럼의 문자셋을 단순 ASCII 타입으로 지정했다면, `1~255` 사이의 숫자로 문자를 표현할 수 있기에 길이 정보를 1바이트로 표현한다.
  - player 컬럼에 문자열 `kane` 을 저장할 경우, 그리고 `player` 컬럼의 문자셋을 UTF-8 로 지정했다면, 2바이트(1 ~ 65535) 사이의 숫자로 문자를 표현하게 되기에 길이 정보를 2바이트로 표현한다.<br>

<br>

**VARCHAR 의 단점과 VARCHAR를 사용하면 좋은 경우**<br>

VARCHAR 의 단점

- VARCHAR 는 공간을 절약할 수 있다는 사실은 성능에는 도움이 된다.
- 하지만 행의 길이가 가변적이기에 업데이트할 때 행의 크기가 변경될 수 있다. 행이 더 커지고 더 이상 원래 위치에 끼워지지 않을 경우 저장공간의 파편화 현상이 발생한다.
- InnoDB엔진은 행을 맞추기 위해 페이지 분할을 해야 할 수 있다. 
  (스토리지 엔진마다 동작이 다르다. 어떤 스토리지 엔진은 데이터를 업데이트하지 못하게 되는 경우도 있다.)

VARCHAR 를 사용하면 좋은 경우

- 최대 열 길이가 평균 길이보다 훨씬 길때 
- 필드에 대한 업데이트가 드물어서 조각화가 문제되지 않을 경우
- UTF-8 과 같은 복잡한 문자셋을 사용할 때 사용하면 좋다.
  - 이때 각 문자는 가변 바이트의 스토리지를 사용한다.



**CHAR 의 장단점과 CHAR를 사용하면 좋은 경우**<br>

**CHAR 의 장단점**<br>

CHAR은 고정 길이 행을 가지고 있어서 조각화되기 쉽다는 점은 VARCHAR 에 비해 장점이 된다.

짧은 길이의 문자열을 다룰 경우 역시 VARCHAR 보다 CHAR가 좋다.

e.g. 'Y', 'N' 같은 문자를 저장하는 경우

- CHAR(1) 은 단일 바이트 문자 집합에서 1바이트만 사용하지만, 
- VARCHAR(1) 은 길이 정보를 표현하는 바이트를 포함해 2바이트를 사용하게 된다.

<br>

 **CHAR 를 사용하면 좋은 경우**<br>

- 짧은 문자열을 저장하려는 경우 또는 모든 값의 길이가 거의 동일한 경우에 유용하다.
  - e.g. CHAR(10) 타입 컬럼 `player`
    - `player` 컬럼에 `kane` 을 저장할 경우 실제로 스토리지 엔진이 디스크에 데이터를 저장할 때 10바이트의 공간을 고정적으로 지정해 저장하게 된다. 
  - e.g. `MD5` 인코딩된 사용자 암호
    - MD5 방식으로 인코딩된 데이터는 항상 길이가 동일하다. 암호를 MD5로 인코딩했다고 해보자. 이런 경우 MD5로 인코딩된 문자열은 `CHAR` 타입을 이용하기에 적절하다.
- 자주 변경되는 데이터일 경우
  - CHAR 은 고정길이 행을 가지고 있기에 조각화되기 쉽다. 따라서 자주 변경되는 데이터에 CHAR 를 사용하면 좋다.
    - 디스크를 사용하면 할수록 스토리지 엔진을 사용하면 할 수록 파편화가 발생할수밖에 없다. 따라서 조각화되기 쉬운 CHAR를 유연하게 이용하여 디스크를 조각화하여 사용하면 좋다.

<br>

**CHAR의 후행공백 예제**<br>

e.g.

```sql
CREATE TABLE char_test(char_col CHAR(10));

INSERT INTO char_test(char_col) 
VALUES ('string1'),(' string2'),('string3 ');


-- 아래의 경우 값ㅇ르 검색할 때 후행 공백이 제거된다.
SELECT CONCAT("'", char_col, "'")
FROM char_test;

-- 결과값

'string1'
' string2'
'string3'
```

<br>

e.g.

```sql
SELECT CONCAT("'", varchar_col, "'") 
FROM varchar_test;

-- 
'string1'
' string2'
'string3 '
```

<br>

**관대함은 현명하지 못할 수 있다.**<br>

'hello' 값을 저장할 때 VARCHAR(5) 및 VARCHAR(200) 열에 동일한 양의 공간이 필요하다. 더 짧은 열을 사용하는 것은 이익이 되는 것일까?<br>

결론만 따지면, 이익이 된다. 더 큰 열을 사용하면 훨씬 더 많은 메모리를 사용할 수 있다. MySQL 은 종종 내부적으로 값을 유지하기 위해 고정 크기의 메모리 청크를 할당하기 때문이다.<br>

이것은 메모리 내의 임시 테이블을 사용하는 정렬 또는 작업에 좋지 않다. 디스크에 있는 임시 테이블을 사용하는 파일 정렬에도 동일한 일이 발생한다. <br>

가장 좋은 전략은 실제로 필요한 만큼만 공간을 할당하는 것이다.<br>

<br>



## BLOB 과 TEXT

+

## 문자열, ENUM

## DATE, TIME

+

## 비트 팩 데이터 타입

## JSON 데이터

+

<br>

<br>

# 식별자 컬럼에 대한 데이터 타입 선택

`식별자 선택` 에서는 아래의 대표적인 데이터 타입들에 대한 팁들을 정리했다.

- 정수타입
- ENUM, SET
- 문자열 타입
- IPv4

<br>

식별자로 사용될 컬럼에 적절한 데이터 타입을 선택하는 것은 중요하다. 다른 테이블의 컬럼과 조인하여 조회에 사용할 가능성이 다른 컬럼보다 높다. 조인으로 사용하게 될 경우 같은 데이터 타입을 사용하게 되므로 주의해서 데이터 타입을 선택해야 한다.<br>

식별자로 사용될 컬럼의 데이터 타입을 선택할 때 해당 컬럼이 계산/비교를 위해 사용되는 경우도 고려해야 한다. <br>

e.g.<br>

>  MySQL은 `ENUM`, `SET` 타입을 내부적으로 정수로 저장하지만, 문자열 컨텍스트에서 비교시에는 문자열로 변환한다.<br>

<br>

**타입을 일치시키자.**<br>

데이터 타입을 선택한 후에는 모든 테이블에서 같은 타입을 선택해야 한다. 가급적 식별자 로 사용되는 컬럼은 `UNSIGNED` 속성 까지 정확하게 일치해야 한다. 데이터 타입을 혼합하면 성능문제가 발생할 수 있다. 

성능문제가 발생하지 않더라도 비교시 암시적으로 비교를 수행하게 되는 경우가 있는데 이럴 때 찾기 어려운 오류가 발생하게 된다. 

<br>

**필요한 값 범위를 저장할 수 있는 가장 작은 크기를 선택하고, 필요한 경우 향후 확장할 수 있는 공간을 확보하자.**<br>

e.g. 미국의 주(state) 이름을 저장하는 `state_id` 컬럼

미국의 주(state) 이름은 수천, 수백만 종류가 존재하는 것이 아니기에 굳이 `INT` 를 사용하지 않아도 된다. 3바이트 더 작은 `TINYINT` 면 충분하다. 다른 테이블에서 이 값을 외래키로 사용할 경우 3바이트 차이가 큰 차이를 만들어낼 수 있다.<br>

<br>

## 정수 타입

정수는 빠르고 `AUTO_INCREMENT` 와 함께 동작하기에 일반적으로 식별자에 가장 적합하다. 단, 정수 타입의 한계를 초과해 데이터가 새로 추가될 경우가 있을지도 고려해서 데이터의 타입의 범위를 고려해야 한다.<br>

예상하지 못한 정수 부족과 관련된 문제로 인한시스템 다운 사례가 발생하는 경우도 있다.<br>

<br>

## ENUM, SET

`ENUM`, `SET` 타입은 상태, 또는 타입 값을 포함하는 정적 `정적 테이블` 에는 적합할 수 있지만 일반적으로 식별자에 적합하지 않다. `ENUM` 및 `SET` 컬럼은 주문 상태, 제품 유형과 같은 정보를 보유하는 데에 적합하다.<br>

<br>

## 문자열 타입

식별자로 문자열 타입을 사용하는 것은 권장되지 않는다. 식별자 컬럼에 문자열 타입을 지정하면 공간을 많이 차지하고 일반적으로 정수 유형보다 느리기에 가급적 사용하지 않는 것이 권장된다.<br>

**`MD5`, `SHA1` , `UUID` 등을 식별자 컬럼의 데이터 타입으로 사용할 경우**<br>

임의의 문자열을 식별자 컬럼으로 사용하는 것은 주의해야 한다. INSERT, SELECT 쿼리가 느려질수 있다.

- INSERT 된 값이 인덱스의 임의의 위치에 있어야 하기 때문에 INSERT 쿼리가 느려진다.
  - 이로 인해 클러스터 형 저장소 엔진에 대한 페이지 분할, 임의의 디스크 액세스 및 클러스터형 인덱스 조각화가 발생한다.
- 논리적으로는 인접한 행이 디스크와 메모리에 광범위하게 분산된다. 따라서 select 쿼리가 느려진다.
- 랜덤 값은 캐싱이 작동하는 방식인 참조 인접성을 무효화한다.
  - 따라서 모든 유형의 쿼리에 대해 캐시 성능이 저하된다.
  - 전체 데이터 세트가 동일하게 `핫` 하다면 데이터의 특정 부분을 메모리에 캐시하는 이점이 없다.(캐시 적중률이 높지 않고 매번 새로운 데이터를 조회해야 한다면 이점이 없다는 이야기)
  - 작업 세트가 메모리에 맞지 않으면(메모리가 충분하지 않으면) 캐시에 많은 플러시와 누락이 발생한다.

<br>

**`UUID` 타입을 꼭 식별자 컬럼에 지정해야 할 경우**

저장시

- UNHEX -> Binary(16) 컬럼에 저장 

읽을때

- Binary(16) 컬럼 내의 값르 조회 -> 검색하려는 UUID 데이터를 `HEX(16)` 으로 변환해 Binary(16) 타입 컬럼을 조회

<br>

`UUID` 값을 저장할 경우 저장시에는 아래의 방식들을 통해 정수값으로 변환하자.

- 대시를 제거한다
- 또는 UNHEX() 함수로 `UUID` 값을 16바이트 숫자로 변환.
  - 저장시에는 BINARY(16) 타입의 컬럼에 저장한다.

<BR>

`BINARY(16)` 타입의 컬럼에 저장된 `UUID` 값을 읽어들일 때는 아래의 방식으로 읽어들이자.

- 16진수를 `BINARY(16)` 타입 컬럼에 `UNHEX()` 함수로 변환한 16바이트 숫자는 
- `HEX()` 함수를 이용해 16진수 형식으로 값들을 검색할 수 있다.

<br>

## IPv4 표현

IP 주소는 `VARCHAR(15)` 타입의 문자열 컬럼으로 ipv4로 저장하기보다는 가급적 `unsigned` 정수로 저장하는 것이 권장된다.<br>

MySQL 에서는 `INET_ATON()` , `INET_NTOA()` 함수를 제공하는데, 이 함수로 'IP 문자열 -> 정수' 변환, '정수 -> IP 문자열' 변환을 수행할 수 있다.<br> 

<br>

# MySQL의 스키마 설계시 주요 문제들

- 너무 많은 컬럼
- 너무 많은 조인
- 지나친 ENUM 사용
- 위장한 ENUM
- NULL 의 지나친 배제

<br>

# 스키마 관리

데브옵스 관점. (추후 정리)

liquibase, flyway, gh-ost,... 트리거, 운영중의 시키마 변경 실행,...

<br>

# 요약











